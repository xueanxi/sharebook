# 小说转漫画故事板生成功能设计文档

## 0. 开发环境
使用conda activate langchain激活，不需要额外安装依赖。

## 1. 功能概述

本功能旨在将清洗后的小说章节内容转换为适合文生图的漫画画面文案，通过智能段落分割、场景分割和视觉文案生成，最终输出结构化的有声漫画数据。

## 2. 技术栈

基于LangChain v1.0.0技术栈实现，主要使用以下组件：

- **LangChain Core**: 核心功能
- **LangChain Community**: 第三方集成
- **LangChain OpenAI**: OpenAI集成
- **LangGraph**: 底层编排引擎，用于构建状态化智能体工作流

## 3. 输入数据

### 3.1 小说章节内容
- **位置**：`data/cleaned_novel/`
- **格式**：每个章节一个txt文件，文件名包含章节标题（UTF-8编码）
- **内容**：已清洗的小说文本，去除无关格式和内容
- **文件命名规范**：`第X章 章节标题.txt`（如：`第一章 遇强则强.txt`）
- **文本要求**：
  - 纯文本格式，无HTML标签或其他格式标记
  - 段落之间用双换行符分隔（`\n\n`）
  - 对话使用引号（""或「」）标识
  - 最小章节长度：500字符
  - 最大章节长度：50,000字符

### 3.2 角色数据
- **位置**：`data/characters/characters.csv`
- **格式**：CSV文件，UTF-8编码，包含以下字段：
  ```csv
  姓名,别名,性别,外貌特征,服装特点,性格特点,角色类型
  ```
- **字段说明**：
  - `姓名`：角色主要名称，必填
  - `别名`：其他称呼或昵称，可选
  - `性别`：男/女/其他，可选
  - `外貌特征`：身高、体型、发型、特殊标记等，可选
  - `服装特点`：常用服装风格、特殊装备等，可选
  - `性格特点`：主要性格特征，可选
  - `角色类型`：主角/配角/反派/路人等，可选
- **用途**：为视觉文案生成提供角色一致性参考
- **数据要求**：
  - 至少包含主要角色的姓名
  - 每行一个角色，无空行
  - 姓名字段不能为空

## 4. 处理流程

### 4.1 整体流程图

```
小说章节内容
    ↓
智能段落分割
    ↓
场景分割Agent（支持并行/顺序处理）
    ↓
视觉文案+旁白生成Agent（支持并行/顺序处理）
    ↓
输出：结构化的场景描述+旁白数据
```

### 4.2 处理模式

系统支持两种处理模式：

#### 4.2.1 并行处理模式（默认）
- 使用固定5个工作节点的并行工作流
- 通过LangGraph的StateGraph实现状态管理
- 自动将段落/场景平均分配给各个工作者
- 支持错误处理和自动回退到顺序模式

#### 4.2.2 顺序处理模式
- 传统的串行处理方式
- 适用于小规模数据或并行处理失败的情况
- 作为并行处理的回退方案

### 4.2 详细步骤

#### 4.2.1 智能段落分割

**场景描述**：将长章节分割为适合Agent处理的段落，避免上下文过长导致处理困难。

**具体操作**：
1. **预处理文本**：
   - 标准化换行符为`\n`
   - 删除多余空白字符（连续空格、制表符）
   - 删除连续3个或以上的换行符，替换为双换行符
   - 删除首尾空白字符

2. **自然段落分割**：
   - 根据双换行符（`\n\n`）分割为自然段落
   - 过滤空段落（仅包含空白字符的段落）
   - 保留原始段落顺序

3. **内容类型识别**：
   - **对话段落**：包含引号（""「」）或对话标记（说：、道：、喊道：等）
   - **动作段落**：包含动作动词（走、跑、跳、飞、打、杀、攻击等）
   - **环境段落**：包含环境描述词汇（天空、大地、山、水、森林等）
   - **混合段落**：包含多种类型内容

4. **元数据提取**：
   - **角色提及**：从角色CSV中提取出现的角色名称
   - **对话数量**：统计对话段落数量
   - **动作数量**：统计动作段落数量
   - **环境数量**：统计环境段落数量

5. **长度控制**：
   - 最大段落长度：500字符
   - 最小段落长度：50字符
   - 超长段落：在适当位置（句号、场景转换点）分割
   - 过短段落：与相邻同类型段落合并

6. **上下文关联**：
   - 前一段落概要：取前一段落的前50字符
   - 下一段落预览：取下一段落的前50字符
   - 段落序号：从0开始递增

**伪代码**：
```python
def split_chapter_to_segments(chapter_text: str, max_length: int = 500):
    # 1. 预处理文本
    normalized_text = normalize_text(chapter_text)
    
    # 2. 按自然段落分割
    paragraphs = split_by_paragraphs(normalized_text)
    
    # 3. 分析段落类型和提取元数据
    segments = []
    current_segment = ""
    current_metadata = extract_metadata()
    
    # 4. 根据长度限制和内容类型合并段落
    for paragraph in paragraphs:
        para_type = analyze_paragraph_type(paragraph)
        update_metadata(current_metadata, paragraph, para_type)
        
        if length_check(current_segment + paragraph, max_length):
            current_segment += paragraph
        else:
            segments.append(create_segment(current_segment, current_metadata))
            current_segment = paragraph
            current_metadata = reset_metadata(paragraph, para_type)
    
    # 5. 添加上下文关联信息
    for segment in segments:
        add_context_info(segment)
    
    return segments
```

**数据协议**：
```json
{
    "text": "段落文本内容",
    "metadata": {
        "dialogue_count": "对话数量",
        "action_count": "动作数量",
        "environment_count": "环境描述数量",
        "character_mentions": ["提及的角色列表"],
        "previous_segment_summary": "前一段落概要",
        "next_segment_preview": "下一段落预览",
        "segment_index": "段落序号"
    }
}
```

#### 4.2.2 场景分割Agent

**场景描述**：基于漫画逻辑，将段落内容分割为适合视觉表达的独立场景。

**具体操作**：
1. **场景边界识别**：
   - **时间变化**：识别时间标记（早晨、中午、夜晚、次日等）
   - **地点变化**：识别地点标记（室内、室外、山洞、宫殿等）
   - **人物变化**：识别人物出场/退场
   - **事件变化**：识别动作或事件的明显转折

2. **视觉元素提取**：
   - **环境元素**：建筑、自然景观、天气、光线等
   - **角色元素**：角色外观、表情、姿态、动作等
   - **物品元素**：武器、道具、特殊物品等
   - **情绪元素**：紧张、轻松、悲伤、愤怒等氛围

3. **场景重要性评估**（1-10分）：
   - **9-10分**：关键情节转折、重要对话、高潮场面
   - **7-8分**：重要动作、角色发展、关键信息
   - **5-6分**：一般情节、过渡场景、环境描述
   - **1-4分**：简单描写、背景信息、次要细节

4. **视觉表现适合度评估**（1-10分）：
   - **9-10分**：动作激烈、视觉冲击力强、构图复杂
   - **7-8分**：有明显画面感、角色互动、特殊环境
   - **5-6分**：静态场景、简单对话、一般环境
   - **1-4分**：心理描写、抽象概念、难以视觉化

5. **场景连贯性检查**：
   - 确保场景之间有合理的过渡
   - 避免突兀的场景跳跃
   - 保持角色状态的一致性

6. **角色状态追踪**：
   - 记录角色位置变化
   - 记录角色情绪变化
   - 记录角色服装/装备变化

**Agent提示词模板**：
```
你是一个专业的小说场景分析专家，擅长从小说文本中识别和提取关键场景信息。

任务：分析以下小说段落，识别其中的关键场景，并提取场景信息。

背景信息：
- 小说类型：{novel_type}
- 当前章节：{chapter_title}
- 前一场景概要：{previous_scene_summary}
- 相关角色信息：{character_info}

文本内容：
{segment_text}

请按以下要求分析：
1. 识别场景数量（每个场景应包含连贯的环境和动作）
2. 对每个场景提取以下信息：
   - 场景描述（环境、氛围、时间等）
   - 出现的角色及其状态
   - 主要动作或事件
   - 场景情绪基调
   - 场景重要性评分（1-10分）
   - 是否适合用视觉表现（1-10分）

输出格式（JSON）：{
    "scenes": [
        {
            "scene_id": "场景编号",
            "scene_description": "场景描述",
            "environment": "环境细节",
            "atmosphere": "氛围描述",
            "time": "时间设定",
            "characters": [
                {
                    "name": "角色名",
                    "appearance": "外观描述",
                    "expression": "表情",
                    "action": "主要动作",
                    "emotion": "情绪状态"
                }
            ],
            "main_action": "主要动作或事件",
            "emotional_tone": "情绪基调",
            "importance_score": 重要性评分,
            "visual_suitability": 视觉表现适合度,
            "transition_cue": "场景转换提示"
        }
    ]
}
```

**伪代码**：
```python
class SceneSplitterAgent:
    def __init__(self, llm, character_data):
        self.llm = llm
        self.character_data = character_data
        self.scene_chain = create_llm_chain(SCENE_SPLITTER_PROMPT)
    
    def split_segment_to_scenes(self, segment, context):
        # 1. 准备角色信息
        character_info = format_character_info(segment.metadata.character_mentions)
        
        # 2. 调用LLM进行场景分析
        result = self.scene_chain.run(
            novel_type=context.novel_type,
            chapter_title=context.chapter_title,
            previous_scene_summary=context.previous_scene_summary,
            character_info=character_info,
            segment_text=segment.text
        )
        
        # 3. 解析结果并添加元数据
        scenes = parse_scene_result(result)
        for scene in scenes:
            add_scene_metadata(scene, segment.metadata)
        
        return scenes
```

**数据协议**：
```json
{
    "scene_id": "场景唯一标识",
    "scene_description": "场景的总体描述",
    "environment": "环境细节描述",
    "atmosphere": "氛围描述",
    "time": "时间设定",
    "characters": [
        {
            "name": "角色名称",
            "appearance": "外观描述",
            "expression": "表情描述",
            "action": "主要动作",
            "emotion": "情绪状态"
        }
    ],
    "main_action": "主要动作或事件",
    "emotional_tone": "情绪基调",
    "importance_score": 重要性评分(1-10),
    "visual_suitability": 视觉表现适合度(1-10),
    "transition_cue": "场景转换提示",
    "segment_index": "所属段落序号",
    "scene_index_in_segment": "在段落中的场景序号"
}
```

#### 4.2.3 视觉文案+旁白生成Agent

**场景描述**：基于场景信息，生成适合漫画表现的视觉描述和旁白文案。

**具体操作**：
1. **视觉构图设计**：
   - **画面类型**：
     - 全景：展示整体环境、多角色互动
     - 中景：角色半身、部分环境、动作展示
     - 特写：角色面部、重要物品、细节表现
   - **拍摄角度**：
     - 平视：标准视角，通用场景
     - 俯视：表现弱势、全景展示
     - 仰视：表现强势、英雄形象
   - **画面布局**：黄金分割、对称构图、引导线等

2. **角色姿态设计**：
   - **姿态**：站立、坐姿、战斗姿态、特殊动作等
   - **表情**：喜、怒、哀、惊、专注等情绪表现
   - **位置**：在画面中的具体位置（左、右、中心等）
   - **服装细节**：服装褶皱、装备状态、破损程度等

3. **环境细节描述**：
   - **背景**：建筑风格、自然景观、室内装饰等
   - **氛围**：紧张、神秘、温馨、压抑等
   - **光线**：自然光、人工光源、特殊光效等
   - **色彩方案**：主色调、对比色、情感色彩等

4. **风格定义**：
   - **艺术风格**：日式漫画、写实风格、水墨风格等
   - **质量标签**：高清、精细、专业、电影感等
   - **额外细节**：特效、线条风格、渲染方式等

5. **旁白文案生成**：
   - **场景描述**：客观描述场景状态（20-50字）
   - **内心独白**：角色心理活动（10-30字）
   - **情绪渲染**：强化氛围的文字（10-20字）
   - **过渡文案**：连接下一场景的文字（10-20字）

6. **分镜建议**：
   - **分镜类型**：单格、双格、多格、跨页等
   - **对话框位置**：上方、下方、左侧、右侧
   - **特效建议**：速度线、集中线、特效符号等
   - **页面布局**：横向阅读、竖向阅读、特殊排版

**Agent提示词模板**：
```
你是一个专业的漫画视觉设计师和文案专家，擅长将小说场景转换为适合漫画表现的视觉描述和旁白。

任务：基于以下场景信息，生成漫画分镜的视觉描述和旁白文案。

背景信息：
- 小说类型：{novel_type}
- 章节标题：{chapter_title}
- 前一场景概要：{previous_scene_summary}
- 场景重要性：{importance_score}/10
- 视觉表现适合度：{visual_suitability}/10

场景信息：
{scene_info}

角色信息：
{character_details}

请按以下要求生成：

1. **视觉描述**：生成适合文生图模型的详细视觉描述，包括：
   - 画面构图（全景、中景、特写等）
   - 角色姿态和表情
   - 环境细节和氛围
   - 光线和色彩
   - 风格参考（如：日式漫画风格、写实风格等）

2. **旁白文案**：生成与场景匹配的旁白，包括：
   - 场景描述性旁白
   - 角色内心独白（如适用）
   - 情绪渲染文案
   - 过渡性文案

3. **分镜建议**：提供漫画分镜的专业建议：
   - 画面角度（俯视、仰视、平视等）
   - 分镜布局（单格、多格、跨页等）
   - 动态表现（速度线、特效等）
   - 对话框位置和样式

输出格式（JSON）：{
    "visual_description": "详细的视觉描述，适合文生图模型",
    "composition": {
        "shot_type": "画面类型（全景/中景/特写）",
        "angle": "拍摄角度",
        "layout": "画面布局描述",
        "focus": "焦点元素"
    },
    "characters": [
        {
            "name": "角色名",
            "position": "在画面中的位置",
            "pose": "姿态描述",
            "expression": "表情描述",
            "clothing_details": "服装细节",
            "action": "正在执行的动作"
        }
    ],
    "environment": {
        "background": "背景描述",
        "atmosphere": "氛围描述",
        "lighting": "光线描述",
        "color_scheme": "色彩方案"
    },
    "style": {
        "art_style": "艺术风格",
        "quality_tags": "质量标签",
        "additional_details": "额外细节"
    },
    "narration": {
        "scene_description": "场景描述性旁白",
        "inner_monologue": "角色内心独白（如有）",
        "emotional_text": "情绪渲染文案",
        "transition_text": "过渡性文案"
    },
    "storyboard_suggestions": {
        "panel_type": "分镜类型",
        "dialogue_position": "对话框位置",
        "effects": "特效建议",
        "page_layout": "页面布局建议"
    }
}
```

**伪代码**：
```python
class VisualNarrativeAgent:
    def __init__(self, llm, character_data):
        self.llm = llm
        self.character_data = character_data
        self.visual_chain = create_llm_chain(VISUAL_PROMPT)
    
    def generate_visual_narrative(self, scene, context):
        # 1. 准备场景和角色信息
        scene_info = format_scene_info(scene)
        character_details = get_character_details(scene.characters)
        
        # 2. 调用LLM生成视觉描述和旁白
        result = self.visual_chain.run(
            novel_type=context.novel_type,
            chapter_title=context.chapter_title,
            previous_scene_summary=context.previous_scene_summary,
            importance_score=scene.importance_score,
            visual_suitability=scene.visual_suitability,
            scene_info=scene_info,
            character_details=character_details
        )
        
        # 3. 解析结果并添加元数据
        visual_data = parse_visual_result(result)
        visual_data["scene_id"] = scene.scene_id
        visual_data["original_scene"] = scene
        
        return visual_data
```

**数据协议**：
```json
{
    "visual_description": "详细的视觉描述，适合文生图模型",
    "composition": {
        "shot_type": "画面类型（全景/中景/特写）",
        "angle": "拍摄角度",
        "layout": "画面布局描述",
        "focus": "焦点元素"
    },
    "characters": [
        {
            "name": "角色名",
            "position": "在画面中的位置",
            "pose": "姿态描述",
            "expression": "表情描述",
            "clothing_details": "服装细节",
            "action": "正在执行的动作"
        }
    ],
    "environment": {
        "background": "背景描述",
        "atmosphere": "氛围描述",
        "lighting": "光线描述",
        "color_scheme": "色彩方案"
    },
    "style": {
        "art_style": "艺术风格",
        "quality_tags": "质量标签",
        "additional_details": "额外细节"
    },
    "narration": {
        "scene_description": "场景描述性旁白",
        "inner_monologue": "角色内心独白（如有）",
        "emotional_text": "情绪渲染文案",
        "transition_text": "过渡性文案"
    },
    "storyboard_suggestions": {
        "panel_type": "分镜类型",
        "dialogue_position": "对话框位置",
        "effects": "特效建议",
        "page_layout": "页面布局建议"
    },
    "scene_id": "关联的场景ID"
}
```

## 5. 输出数据结构

### 5.1 章节级别输出

每个章节处理完成后，生成一个JSON文件，包含以下结构：

```json
{
    "chapter_info": {
        "chapter_title": "章节标题",
        "chapter_file": "章节文件路径",
        "novel_type": "小说类型",
        "processing_time": "处理时间戳",
        "total_segments": "总段落数",
        "total_scenes": "总场景数",
        "total_storyboards": "总故事板数"
    },
    "basic_stats": {
        "total_segments": "总段落数",
        "total_scenes": "总场景数",
        "total_storyboards": "总故事板数"
    },
    "segments": [
        {
            "segment_id": "段落ID",
            "segment_index": "段落序号",
            "text": "段落文本",
            "metadata": {
                "dialogue_count": "对话数量",
                "action_count": "动作数量",
                "environment_count": "环境描述数量",
                "character_mentions": ["提及的角色列表"],
                "previous_segment_summary": "前一段落概要",
                "next_segment_preview": "下一段落预览"
            },
            "scenes": [
                {
                    "scene_id": "场景ID",
                    "scene_index_in_segment": "场景在段落中的序号",
                    "scene_description": "场景描述",
                    "environment": "环境细节",
                    "atmosphere": "氛围描述",
                    "time": "时间设定",
                    "characters": [
                        {
                            "name": "角色名",
                            "appearance": "外观描述",
                            "expression": "表情",
                            "action": "主要动作",
                            "emotion": "情绪状态"
                        }
                    ],
                    "main_action": "主要动作或事件",
                    "emotional_tone": "情绪基调",
                    "importance_score": 重要性评分,
                    "visual_suitability": 视觉表现适合度,
                    "transition_cue": "场景转换提示",
                    "visual_narrative": {
                        "visual_description": "详细的视觉描述，适合文生图模型",
                        "composition": {
                            "shot_type": "画面类型（全景/中景/特写）",
                            "angle": "拍摄角度",
                            "layout": "画面布局描述",
                            "focus": "焦点元素"
                        },
                        "characters": [
                            {
                                "name": "角色名",
                                "position": "在画面中的位置",
                                "pose": "姿态描述",
                                "expression": "表情描述",
                                "clothing_details": "服装细节",
                                "action": "正在执行的动作"
                            }
                        ],
                        "environment": {
                            "background": "背景描述",
                            "atmosphere": "氛围描述",
                            "lighting": "光线描述",
                            "color_scheme": "色彩方案"
                        },
                        "style": {
                            "art_style": "艺术风格",
                            "quality_tags": "质量标签",
                            "additional_details": "额外细节"
                        },
                        "narration": {
                            "scene_description": "场景描述性旁白",
                            "inner_monologue": "角色内心独白（如有）",
                            "emotional_text": "情绪渲染文案",
                            "transition_text": "过渡性文案"
                        },
                        "storyboard_suggestions": {
                            "panel_type": "分镜类型",
                            "dialogue_position": "对话框位置",
                            "effects": "特效建议",
                            "page_layout": "页面布局建议"
                        }
                    }
                }
            ]
        }
    ],
    "errors": [
        {
            "error_type": "错误类型",
            "error_message": "错误信息",
            "segment_id": "出错段落ID",
            "scene_id": "出错场景ID",
            "timestamp": "错误时间戳",
            "stack_trace": "错误堆栈（如有）"
        }
    ]
}
```

### 5.2 章节处理结果

每个章节处理完成后，输出处理结果摘要：

```json
{
    "processing_summary": {
        "success": true,
        "total_segments": 10,
        "total_scenes": 15,
        "total_storyboards": 15,
        "processing_time": "120.5秒",
        "error_count": 0
    }
}
```

#### 5.3 数据存储格式

1. **文件命名规则**：
   - 章节输出：`data/output/{章节文件名}_storyboards.json`

2. **文件组织结构**：
   ```
   data/output/
   └── storyboards/              # 故事板输出目录
       ├── 第一章 遇强则强_storyboards.json
       ├── 第二章 XXX_storyboards.json
       └── ...
   ```

## 6. 技术实现架构

### 6.1 目录结构

```
src/services/novel_to_comic/
├── __init__.py
├── main.py                     # 主入口，处理流程控制
├── config/
│   ├── __init__.py
│   ├── llm_config.py          # LLM配置（已存在）
│   ├── processing_config.py   # 处理参数配置
│   └── prompts.py             # 提示词模板
├── core/
│   ├── __init__.py
│   ├── segmenter.py           # 智能段落分割器
│   ├── scene_splitter.py      # 场景分割Agent
│   ├── visual_narrative.py    # 视觉文案生成Agent
│   ├── parallel_scene_splitter.py  # 并行场景分割工作流
│   ├── parallel_visual_narrative.py # 并行视觉生成工作流
│   └── workflow.py            # 主工作流定义，支持并行/顺序模式
├── utils/
│   ├── __init__.py
│   ├── file_handler.py        # 文件处理工具
│   ├── text_processor.py      # 文本处理工具
│   ├── character_manager.py   # 角色数据管理
│   ├── data_validator.py      # 数据验证工具
│   └── logger.py              # 日志工具
├── models/
│   ├── __init__.py
│   ├── data_models.py         # 数据模型定义
│   └── result_models.py       # 结果模型定义
└── tests/
    ├── __init__.py
    ├── test_segmenter.py
    ├── test_scene_splitter.py
    ├── test_visual_narrative.py
    └── test_integration.py
```

### 6.2 并行处理流程

**并行处理架构**：
1. **LangGraph状态管理**：使用StateGraph管理并行处理状态
2. **固定工作者节点**：创建5个固定的并行工作者节点
3. **任务分配**：将段落/场景平均分配给各个工作者
4. **结果聚合**：自动聚合各工作者的处理结果
5. **错误处理**：支持自动回退到顺序处理模式

**并行场景分割工作流**：
```python
class ParallelSceneSplitterWorkflow:
    def __init__(self, character_manager, num_workers=5):
        self.num_workers = num_workers
        self.workflow = self._build_workflow()
    
    def process_segments_parallel(self, segments, context):
        # 1. 初始化状态
        initial_state = {
            "segments": segments,
            "context": context,
            "all_scenes": [],
            "errors": []
        }
        
        # 2. 执行并行工作流
        result = self.workflow.invoke(initial_state)
        
        # 3. 返回聚合结果
        return result["all_scenes"]
```

**并行视觉生成工作流**：
```python
class ParallelVisualNarrativeWorkflow:
    def __init__(self, character_manager, num_workers=5):
        self.num_workers = num_workers
        self.workflow = self._build_workflow()
    
    def process_scenes_parallel(self, scenes, context):
        # 1. 初始化状态
        initial_state = {
            "scenes": scenes,
            "context": context,
            "all_visual_narratives": [],
            "errors": []
        }
        
        # 2. 执行并行工作流
        result = self.workflow.invoke(initial_state)
        
        # 3. 返回聚合结果
        return result["all_visual_narratives"]
```

**主工作流**：
```python
class NovelToComicWorkflow:
    def __init__(self, enable_parallel=None):
        # 初始化组件
        self.segmenter = IntelligentSegmenter()
        self.scene_splitter = SceneSplitterAgent()
        self.visual_narrative = VisualNarrativeAgent()
        
        # 并行工作流（可选）
        if enable_parallel:
            self.parallel_scene_splitter = ParallelSceneSplitterWorkflow()
            self.parallel_visual_workflow = ParallelVisualNarrativeWorkflow()
    
    def process_chapter(self, chapter_file, chapter_title, novel_type):
        # 1. 读取章节内容
        chapter_text = self.file_handler.read_text_file(chapter_file)
        
        # 2. 智能段落分割
        segments = self.segmenter.split_chapter_to_segments(chapter_text)
        
        # 3. 场景分割（并行/顺序）
        if self.enable_parallel and len(segments) > 1:
            try:
                all_scenes = self.parallel_scene_splitter.process_segments_parallel(segments, context)
            except Exception as e:
                # 自动回退到顺序模式
                all_scenes = self._process_segments_sequentially(segments, context)
        else:
            all_scenes = self._process_segments_sequentially(segments, context)
        
        # 4. 视觉生成（并行/顺序）
        if self.enable_parallel and len(all_scenes) > 1:
            try:
                visual_narratives = self.parallel_visual_workflow.process_scenes_parallel(all_scenes, context)
            except Exception as e:
                # 自动回退到顺序模式
                visual_narratives = self._process_scenes_sequentially(all_scenes, context)
        else:
            visual_narratives = self._process_scenes_sequentially(all_scenes, context)
        
        # 5. 保存结果
        result = self._create_chapter_result(chapter_title, segments, all_scenes, visual_narratives)
        output_path = self.save_result(result)
        
        return result
```

## 7. 配置与参数

### 7.1 模型配置

使用项目现有的LLM配置方法，通过编辑 `config/llm_config.py` 文件进行配置：

```python
# 在config/llm_config.py中配置
class LLMConfig:
    # 本地vllm
    # API_BASE = "http://127.0.0.1:8000/v1"
    # MODEL_NAME = "local-llm"
    # API_KEY = "123"

    # 服务器vllm
    API_BASE = "http://192.168.3.46:8000/v1"
    MODEL_NAME = "local-llm"
    API_KEY = "123"
    
    # 请求配置
    TIMEOUT = 30  # 请求超时时间（秒）
    MAX_RETRIES = 8  # 最大重试次数
    TEMPERATURE = 0.4  # 默认温度参数
    
    # 模型参数
    MAX_TOKENS = 2000  # 最大生成token数
    TOP_P = 0.9  # 核采样参数
```

**Agent配置**：
```python
# 场景分割Agent配置
SCENE_SPLITTER_CONFIG = {
    "temperature": 0.3,  # 较低温度，确保场景分割的一致性
    "max_tokens": 2000,
    **LLMConfig.get_openai_kwargs()
}

# 视觉文案生成Agent配置
VISUAL_GENERATOR_CONFIG = {
    "temperature": 0.5,  # 中等温度，平衡创造性和一致性
    "max_tokens": 3000,
    **LLMConfig.get_openai_kwargs()
}
```

### 7.2 分割参数

```python
# 在config/processing_config.py中定义
SEGMENT_MAX_LENGTH = 500  # 每个段落最大长度
SCENE_MIN_LENGTH = 100    # 每个场景最小长度
SCENE_MAX_LENGTH = 300    # 每个场景最大长度

# 并行处理配置
ENABLE_PARALLEL_SCENE_SPLITTING = True  # 是否启用并行场景分割
MAX_SCENE_SPLITTING_CONCURRENT = 5      # 最大并行工作者数量
ENABLE_PARALLEL_VISUAL_GENERATION = True  # 是否启用并行视觉生成
MAX_VISUAL_GENERATION_CONCURRENT = 5      # 最大并行工作者数量
```

### 7.3 并行处理配置

```python
# 并行工作流配置
PARALLEL_CONFIG = {
    # 工作者数量
    "num_workers": 5,
    
    # 任务分配策略
    "task_distribution": "even",  # 均匀分配
    
    # 错误处理
    "fallback_to_sequential": True,  # 失败时回退到顺序处理
    "max_retries": 3,  # 最大重试次数
    
    # 超时设置
    "worker_timeout": 300,  # 单个工作者超时时间（秒）
    "total_timeout": 600,   # 整体超时时间（秒）
}
```

## 8. 错误处理与日志

### 8.1 错误处理策略

- **模型调用失败**：
  - 连接错误：等待2秒后重试，最多重试3次
  - 超时错误：增加超时时间，最多重试2次
  - API限制：等待30秒后重试，最多重试2次
  - 认证错误：立即停止，记录错误日志

- **内容过长**：
  - 输入文本超过模型限制：自动分割为多个请求
  - 输出内容过长：截断并添加"[内容被截断]"标记
  - 上下文过长：保留最近的内容，删除早期内容

- **角色数据缺失**：
  - CSV文件不存在：使用默认角色描述
  - 角色名称不匹配：使用通用角色模板
  - 角色信息不完整：使用部分可用信息

- **输出格式错误**：
  - JSON解析失败：尝试修复常见格式错误
  - 字段缺失：使用默认值填充
  - 数据类型错误：尝试类型转换

### 8.2 日志记录

使用项目的日志系统记录关键信息：

**日志级别**：
- **DEBUG**：详细的处理步骤、中间结果
- **INFO**：处理进度、成功操作
- **WARNING**：非致命错误、降级处理、重试操作
- **ERROR**：致命错误、处理失败、异常情况

**日志内容**：
- **处理进度**：章节处理进度、段落处理进度、场景处理进度
- **模型调用**：请求参数、响应状态
- **错误信息**：错误类型、错误消息

**日志格式**：
```
[时间戳] [级别] [模块] 消息内容
```

## 9. 并行处理设计说明

当前版本支持并行和顺序两种处理模式：

### 9.1 并行处理特性
- **固定工作者节点**：使用5个固定的并行工作者节点
- **任务均匀分配**：自动将段落/场景平均分配给各工作者
- **状态管理**：使用LangGraph的StateGraph进行状态管理
- **自动回退**：并行处理失败时自动回退到顺序模式
- **错误处理**：每个工作者独立处理错误，不影响其他工作者

### 9.2 顺序处理特性
- **传统串行**：按步骤顺序处理每个段落和场景
- **简单可靠**：适用于小规模数据或调试场景
- **资源友好**：占用系统资源较少

### 9.3 性能考虑
- **并行优势**：大幅提高处理速度，特别是对于长章节
- **内存管理**：并行处理可能增加内存使用
- **API限制**：需要注意LLM API的并发限制
- **稳定性**：顺序模式作为备用方案确保系统稳定性

## 10. 使用示例

## 10. 使用示例

### 10.1 单章节处理

```python
from src.services.novel_to_comic.main import NovelToComicWorkflow
from config.llm_config import LLMConfig

# 确保LLM配置正确
LLMConfig.validate_config()

# 创建工作流实例（默认启用并行处理）
workflow = NovelToComicWorkflow()

# 处理单个章节
result = workflow.process_chapter(
    chapter_file="data/cleaned_novel/第一章 遇强则强.txt",
    chapter_title="第一章 遇强则强",
    novel_type="玄幻"
)

# 保存结果
output_path = workflow.save_result(result)

# 检查处理结果
if result.errors:
    print(f"处理过程中发生错误：{len(result.errors)} 个")
else:
    print(f"处理成功，输出文件：{output_path}")
```

### 10.2 自定义配置

```python
from config.llm_config import LLMConfig
from src.services.novel_to_comic.config.processing_config import (
    ENABLE_PARALLEL_SCENE_SPLITTING,
    MAX_SCENE_SPLITTING_CONCURRENT
)

# 自定义LLM配置
LLMConfig.API_BASE = "http://your-custom-llm-server:8000/v1"
LLMConfig.MODEL_NAME = "your-custom-model"
LLMConfig.TEMPERATURE = 0.3

# 自定义并行处理配置
ENABLE_PARALLEL_SCENE_SPLITTING = True
MAX_SCENE_SPLITTING_CONCURRENT = 8  # 使用8个并行工作者

# 使用自定义配置
workflow = NovelToComicWorkflow(enable_parallel=True)
result = workflow.process_chapter(
    chapter_file="data/cleaned_novel/第一章 遇强则强.txt",
    chapter_title="第一章 遇强则强",
    novel_type="玄幻"
)
```

### 10.3 顺序处理模式

```python
# 强制使用顺序处理模式
workflow = NovelToComicWorkflow(enable_parallel=False)

# 处理章节（使用顺序模式）
result = workflow.process_chapter(
    chapter_file="data/cleaned_novel/第一章 遇强则强.txt",
    chapter_title="第一章 遇强则强",
    novel_type="玄幻"
)

# 顺序模式适用于：
# 1. 调试和开发阶段
# 2. 小规模数据处理
# 3. API并发限制严格的环境
```

## 11. 扩展性考虑

### 11.1 已实现扩展

- **并行处理**：支持并行和顺序两种处理模式
- **动态工作者**：可配置并行工作者数量
- **自动回退**：并行处理失败时自动回退到顺序模式
- **状态管理**：使用LangGraph进行复杂的状态管理

### 11.2 简单扩展

- 支持切换不同的LLM模型
- 支持基本的参数调整
- 支持自定义任务分配策略

### 11.3 未来扩展

- 支持不同漫画风格的视觉描述模板
- 考虑添加人工调整功能
- 支持动态工作者数量调整
- 支持更复杂的任务分配算法
- 支持分布式处理

## 12. 测试策略

### 12.1 基本测试

- 测试文本分割功能
- 测试场景分割功能
- 测试视觉文案生成
- 测试并行处理流程
- 测试自动回退机制

### 12.2 性能测试

- 测试并行处理性能提升
- 测试不同工作者数量的效果
- 测试长章节处理能力
- 测试资源使用情况

### 12.3 错误处理测试

- 测试文件读取错误
- 测试模型调用失败
- 测试数据格式错误
- 测试并行处理中的错误处理
- 测试自动回退功能

### 12.4 集成测试

- 测试完整的处理流程
- 测试不同配置组合
- 测试真实数据场景

## 13. 部署

### 13.1 部署方案

- 支持本地部署
- 支持分布式部署
- 支持容器化部署
- 基本的命令行接口

### 13.2 监控与日志

- 详细的性能日志
- 并行处理状态监控
- 错误统计和分析
- 资源使用监控

## 14. 未来优化方向

1. **风格支持**：支持不同漫画风格的视觉描述生成
2. **参数优化**：根据反馈调整生成参数
3. **界面优化**：提供更友好的用户界面
4. **性能优化**：
   - 动态工作者数量调整
   - 智能任务分配策略
   - 缓存机制优化
5. **扩展功能**：
   - 支持多模态输入
   - 支持实时处理
   - 支持批量处理优化